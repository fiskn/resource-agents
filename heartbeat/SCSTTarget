#!/bin/bash
#
# SCSTTarget
#
# Description:  Exports and manages SCST targets.
#
# Author:       Andreas Kurz
#
# License:      GNU General Public License (GPL)
#
# (c) 2015-2016 Andreas Kurz <andreas.kurz AT gmail DOT com>
#
# This resource agent is derived from the iSCSITarget resource
# agent, which itself is made available to the public under the
# following copyright:
#
# (c) 2009-2010 Florian Haas, Dejan Muhamedagic,
#               and Linux-HA contributors
#
# See usage() function below for more details ...
#
#######################################################################
# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
# Set the iSCSI fabric as default 
OCF_RESKEY_fabric_default="iscsi"
: ${OCF_RESKEY_fabric=${OCF_RESKEY_fabric_default}}

# Listen on 0.0.0.0 by default
OCF_RESKEY_iscsi_portals_default="0.0.0.0"
: ${OCF_RESKEY_iscsi_portals=${OCF_RESKEY_iscsi_portals_default}}

# for debugging this RA
DEBUG_LOG_DIR=/tmp/SCSTTarget.ocf.ra.debug
DEBUG_LOG=$DEBUG_LOG_DIR/${OCF_RESOURCE_INSTANCE}.log
USE_DEBUG_LOG=false
ls_stat_is_dir_0700_root() {
    set -- $(command ls -ldn "$1" 2>/dev/null);
    [[ $1/$3 = drwx?-??-?/0 ]]
}
# try to avoid symlink vuln.
if ls_stat_is_dir_0700_root $DEBUG_LOG_DIR &&
    [[ -w "$DEBUG_LOG" && ! -L "$DEBUG_LOG" ]]
then
    USE_DEBUG_LOG=true
    exec 9>>"$DEBUG_LOG"
    date >&9
    echo "$*" >&9
    env | grep OCF_ | sort >&9
else
    exec 9>/dev/null
fi
# end of debugging aid

# For convenience
SCST_BASE="/sys/kernel/scst_tgt"
FABRIC_BASE="${SCST_BASE}/targets/${OCF_RESKEY_fabric}"
CRM_ATTR_TGT="${HA_SBIN_DIR}/crm_attribute --node ${HOSTNAME} --name local_${OCF_RESKEY_fabric}_targets --lifetime forever"

# Lockfile, to prevent races on multi-target setups
LOCKFILE=${HA_RSCTMP}/SCSTTarget.lock
#######################################################################

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="SCSTTarget" version="0.4.0">
<version>0.4.0</version>

<longdesc lang="en">
Manages SCST targets. A target is a daemon that speaks
 a specific protocol and exports a collection of Logical Units (LUs) .
</longdesc>
<shortdesc lang="en">SCST target export agent</shortdesc>

<parameters>
<parameter name="fabric" required="0" unique="0">
<longdesc lang="en">
The SCST target supports several fabric types. Must be one of "iscsi" or
"qla2x00t". If unspecified, "iscsi" is used.
</longdesc>
<shortdesc lang="en">Specifies the type of fabric</shortdesc>
<content type="string" default="${OCF_RESKEY_fabric_default}"/>
</parameter>

<parameter name="id" required="1" unique="1">
<longdesc lang="en">
ISCSI targets use an iSCSI Qualified Name (IQN). Should follow the conventional
"iqn.yyyy-mm.&lt;reversed domain name&gt;[:identifier]" syntax.
FC targets use a World Wide Port Name (WWPN). Each World Wide Name (WWN)
 is an 8 byte number derived from an IEEE OUI and vendor-supplied information.
For FC targets it is supported to add a white-space separated list of WWPNs
(e.g. all ports on a multi-link HBA)
</longdesc>
<shortdesc lang="en">Target id (IQN or WWPN)</shortdesc>
<content type="string" />
</parameter>

<parameter name="iscsi_portals" required="0" unique="0">
<longdesc lang="en">
White space separated list of iSCSI network portal addresses.
If unset, the default is to create one portal that listens on
${OCF_RESKEY_iscsi_portals_default}.
</longdesc>
<shortdesc lang="en">iSCSI portal addresses</shortdesc>
<content type="string" default="${OCF_RESKEY_iscsi_portals_default}"/>
</parameter>

<parameter name="additional_parameters" required="0" unique="0">
<longdesc lang="en">
Additional target parameters. A space-separated list of "name=value"
pairs which will be passed through to the SCST targets management
interface. The supported parameters are implementation
dependent. Neither the name nor the value may contain whitespace.
</longdesc>
<shortdesc lang="en">List of SCST target parameters</shortdesc>
<content type="string" />
</parameter>

<parameter name="iscsi_incoming_user" required="0" unique="0">
<longdesc lang="en">
A space-separated list of "username:::password" pairs to restrict
incoming target access. This will be ignored for all but iSCSI targets.
Passwords must be at least 12 bytes long. Usernames and passwords must
not contain spaces.
</longdesc>
<shortdesc lang="en">Incoming iSCSI username:::password pairs</shortdesc>
<content type="string" />
</parameter>

<parameter name="iscsi_outgoing_user" required="0" unique="0">
<longdesc lang="en">
An outgoing "username:::password" pair for mutual authentication. This will be
ignored for all but iSCSI targets. The Password must be at least 12 bytes long.
Username and password must not contain spaces.
</longdesc>
<shortdesc lang="en">Outgoing iSCSI username:::password pair</shortdesc>
<content type="string" />
</parameter>

<parameter name="iscsi_incoming_user_discovery" required="0" unique="0">
<longdesc lang="en">
A space-separated list of "username:::password" pairs to restrict
incoming target discovery requests. This will be ignored for all but
iSCSI targets. Passwords must be at least 12 bytes long. Usernames and
passwords must not contain spaces.
contain space.
</longdesc>
<shortdesc lang="en">Incoming iSCSI discovery username:::password pairs</shortdesc>
<content type="string" />
</parameter>

<parameter name="iscsi_outgoing_user_discovery" required="0" unique="0">
<longdesc lang="en">
An outgoing "username:::password" pair for mutual authentication of target
discovery requests. This will be ignored for all but iSCSI targets. The Password
must be at least 12 bytes long. Username and password must not contain spaces.
</longdesc>
<shortdesc lang="en">Outgoing iSCSI discovery username:::password pair</shortdesc>
<content type="string" />
</parameter>
</parameters>

<actions>
<action name="start"        timeout="10" />
<action name="stop"         timeout="10" />
<action name="status"       timeout="10" interval="10" depth="0" />
<action name="monitor"      timeout="10" interval="10" depth="0" />
<action name="meta-data"    timeout="5" />
<action name="validate-all"   timeout="10" />
</actions>
</resource-agent>
END
}

#######################################################################

# Read the SCST sysfs attribute $1. See also scst/README for more information.
scst_sysfs_read() {
    local EAGAIN val

    EAGAIN="Resource temporarily unavailable"
    while true; do
        if val="$(LC_ALL=C cat "$1" 2>&1)"; then
            echo -n "${val%\[key\]}"
            return 0
	elif [ "${val/*: }" != "$EAGAIN" ]; then
            return 1
        fi
        sleep 1
    done
}

# Write $1 into the SCST sysfs attribute $2. See also scst/README for more
# information.
scst_sysfs_write() {
    local EAGAIN status

    EAGAIN="Resource temporarily unavailable"
    if status="$(LC_ALL=C; (echo -n "$1" > "$2") 2>&1)"; then
        return 0
    elif [ "${status/*: }" != "$EAGAIN" ]; then
        return 1
    fi
    scst_sysfs_read /sys/kernel/scst_tgt/last_sysfs_mgmt_res >/dev/null
}

get_index() {
    local index
    declare -a array=( $(echo -n ${2}) )

    for (( index = 0; index < ${#array[@]}; index++ )); do
        if [ "${array[$index]}" == "$1" ]; then
            echo $index
            break
        fi
    done
}

# Add users from $1 and of type $2 to authenticate discovery.
# If $3 is specified it must be an existing target_id.
add_users() {
    local index
    local pair
    local user
    local passwd
    local attribute="add_attribute"
    # Sort the users for creation to allow ordered deletion
    declare -a array=( $(for user in ${1}; do echo ${user};done | sort -bdf) )

    # If a third parameter is defined it has to be
    # a specific target
    [ -n "${3}" ] && attribute="add_target_attribute ${3}"

    for pair in "${array[@]}"; do
        user="${pair%%:::*}"
        passwd="${pair##*:::}"
        # If the username already exists skip creation
        if grep -Eq "^${user}[[:space:]]{1}" ${FABRIC_BASE}/${3}/${2}* 2>/dev/null; then
            ocf_log warn "${OCF_RESOURCE_INSTANCE}: The ${2} \"${user}\" already exists - skipping."
        else
            index=$(get_index "${pair}" "${array[@]}")
            [ ${index} -eq 0 ] && index=""
            scst_sysfs_write "${attribute} ${2}${index} ${user} ${passwd}" ${FABRIC_BASE}/mgmt || {
                ocf_log err "Unable to add ${2} \"${user}\".";
                exit $OCF_ERR_GENERIC
            }
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Created ${2} \"${user}\"."
        fi
    done
}

# Del discovery users from $1 and of type $2.
del_discovery_users() {
    local index
    local pair
    local user
    local passwd

    # Sort the users for creation to allow ordered deletion
    declare -a array=( $(for user in ${1}; do echo ${user};done | sort -bdf) )

    for pair in "${array[@]}"; do
        user="${pair%%:::*}"
        passwd="${pair##*:::}"
        # Check if this is really the user configured, before deleting it.
        if grep -Eq "^${user}[[:space:]]{1}${passwd}" ${FABRIC_BASE}/${2}* 2>/dev/null; then
            index=$(get_index "${pair}" "${array[@]}")
            [ ${index} -eq 0 ] && index=""
            scst_sysfs_write "del_attribute ${2}${index} ${user}" ${FABRIC_BASE}/mgmt || {
                ocf_log err "Unable to delete ${2} \"${user}\".";
                exit $OCF_ERR_GENERIC
            }
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Deleted discovery ${2} \"${user}\"."
        else
            ocf_log warn "${OCF_RESOURCE_INSTANCE}: The ${2} \"${user}\" for discovery was not created by this instance."
        fi
    done
}

SCSTTarget_usage() {
	cat <<END
usage: $0 {start|stop|status|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

SCSTTarget_start() {
    SCSTTarget_monitor
    if [ $? =  $OCF_SUCCESS ]; then
	return $OCF_SUCCESS
    fi

    local ids
    local initiator
    local mod
    local name
    local other_mods
    local param
    local portal
    local value

    # Load core modules
    for mod in scst scst_vdisk scst_disk; do
       ocf_run -q modprobe -s $mod || {
          ocf_log err "Unable to load ${mod} module";
          return $OCF_ERR_INSTALLED
       }
       ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${mod} module loaded."
    done

    # Intel Nehalem processor supports hardware accelerated crc32
    # algorithm with the new CRC32 instruction in SSE 4.2 instruction set.
    if grep -q ' sse4_2 ' /proc/cpuinfo; then
        other_mods="crc32c-intel"
    else
        other_mods="crc32"
    fi

    # Load extra modules
    for mod in $other_mods; do
      ocf_run -q modprobe -s $mod || {
         ocf_log err "Unable to load ${mod} module";
         return $OCF_ERR_INSTALLED
      }
      ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${mod} module loaded."
    done

    # Wait for the lock to manage targets
    ocf_take_lock $LOCKFILE
    ocf_release_lock_on_exit $LOCKFILE

    # Create the target and portals
    case ${OCF_RESKEY_fabric} in
        iscsi)
            # Initiate the fabric if needed
            if [ ! -d "${FABRIC_BASE}" ]; then
                ocf_run -q modprobe -s  iscsi_scst || {
                   ocf_log err "Unable to load iscsi_scst  module";
                   return $OCF_ERR_INSTALLED
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: iscsi_scst module loaded."
            fi

            # Configure incoming/outgoing users for discovery
            if [ -n "${OCF_RESKEY_iscsi_incoming_user_discovery}" ]; then
                 add_users "${OCF_RESKEY_iscsi_incoming_user_discovery}" IncomingUser
            fi
            if [ -n "${OCF_RESKEY_iscsi_outgoing_user_discovery}" ]; then
                 add_users "${OCF_RESKEY_iscsi_outgoing_user_discovery}" OutgoingUser
            fi

            # Create the target
            if [ ! -d "${FABRIC_BASE}/${OCF_RESKEY_id}" ]; then
                scst_sysfs_write "add_target ${OCF_RESKEY_id}" ${FABRIC_BASE}/mgmt || {
                    ocf_log err "Unable to create target ${OCF_RESKEY_id}.";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: iSCSI target ${OCF_RESKEY_id} initialized"
            fi

            # Configure incoming/outgoing users
            if [ -n "${OCF_RESKEY_iscsi_incoming_user}" ]; then
                 add_users "${OCF_RESKEY_iscsi_incoming_user}" IncomingUser "${OCF_RESKEY_id}"
            fi
            if [ -n "${OCF_RESKEY_iscsi_outgoing_user}" ]; then
                 add_users "${OCF_RESKEY_iscsi_outgoing_user}" OutgoingUser "${OCF_RESKEY_id}"
            fi

            # Define allowed portals
            if [ "${OCF_RESKEY_iscsi_portals}" != "${OCF_RESKEY_iscsi_portals_default}" ]; then
                for portal in ${OCF_RESKEY_iscsi_portals}; do
                   if ! grep -qE "${portal}$" ${FABRIC_BASE}/${OCF_RESKEY_id}/allowed_portal* ; then
                       scst_sysfs_write "add_target_attribute ${OCF_RESKEY_id} allowed_portal ${portal}" ${FABRIC_BASE}/mgmt || {
                           ocf_log err "Unable to set allowed portal ${portal} on target ${OCF_RESKEY_id}.";
                           exit $OCF_ERR_GENERIC
                       }
                   fi
                done
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Allowed portals on target ${OCF_RESKEY_id} are set to: ${OCF_RESKEY_iscsi_portals}."
            fi

        ;;
        qla2x00t)
            # Initiate the fabric if needed
            if [ ! -d "${FABRIC_BASE}" ]; then
                for mod in qla2xxx_scst qla2x00tgt; do
                   ocf_run -q modprobe -s $mod || {
                      ocf_log err "Unable to load ${mod} module";
                      return $OCF_ERR_INSTALLED
                   }
                   ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${mod} module loaded."
                done
            fi

            # Create the targets
            for ids in ${OCF_RESKEY_id}; do
                if [ ! -d "${FABRIC_BASE}/${ids}" ]; then
                    scst_sysfs_write "add_target ${ids}" ${FABRIC_BASE}/mgmt || {
                        ocf_log err "Unable to create target ${ids}.";
                        exit $OCF_ERR_GENERIC
                    }
                    ocf_log debug "${OCF_RESOURCE_INSTANCE}: FC target ${OCF_RESKEY_id} initialized"
                fi
            done
        ;;
    esac

    # Set specific target parameters for the target
    for param in ${OCF_RESKEY_additional_parameters}; do
	name=${param%=*}
	value=${param#*=}
        for ids in ${OCF_RESKEY_id}; do
	    if [ -e ${FABRIC_BASE}/${ids}/${name} ]; then
	        scst_sysfs_write "${value}" "${FABRIC_BASE}/${ids}/${name}" || exit $OCF_ERR_GENERIC
	    else
	        ocf_log warn "Unsupported ${OCF_RESKEY_fabric} target parameter ${name}: will be ignored."
	    fi
        done
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set specific parameter ${OCF_RESKEY_additional_parameters} for target ${OCF_RESKEY_id}"

    # SCST targets must have a LUN 0 - create a dummy on target creation.
    # Put LUN 0 in the target default group.
    if [ ! -L "${SCST_BASE}/handlers/vdisk_nullio/LUN0_${OCF_RESKEY_fabric}" ]; then
        scst_sysfs_write "add_device LUN0_${OCF_RESKEY_fabric} dummy=1;size_mb=1" ${SCST_BASE}/handlers/vdisk_nullio/mgmt || {
            ocf_log err "Unable to create dummy device for LUN 0 on target ${OCF_RESKEY_id}.";
            exit $OCF_ERR_GENERIC
        }
        scst_sysfs_write "1" ${SCST_BASE}/handlers/vdisk_nullio/LUN0_${OCF_RESKEY_fabric}/read_zero || \
        ocf_log warn "Unable to enable read_zero option for dummy LUN 0 on target ${OCF_RESKEY_id}."
    fi
    for ids in ${OCF_RESKEY_id}; do
        # Add dummy LUN 0 to the target if it is not already available.
        if [ ! -d "${FABRIC_BASE}/${ids}/luns/0" ]; then
            scst_sysfs_write "add LUN0_${OCF_RESKEY_fabric} 0" ${FABRIC_BASE}/${ids}/luns/mgmt || {
                ocf_log err "Unable to add dummy LUN 0 to target ${OCF_RESKEY_id}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        # Check if LUN 0 is exported but is _not_ our dummy device
        [ "$(scst_sysfs_read ${FABRIC_BASE}/${ids}/luns/0/device/prod_id)" = "LUN0_${OCF_RESKEY_fabric}" ] || {
            ocf_log err "The LUN 0 exported in the default group of target ${OCF_RESKEY_id} is not the expected dummy device.";
            exit $OCF_ERR_GENERIC
        }
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Added dummy LUN 0 to target ${OCF_RESKEY_id}"

    # Enable this specific target
    for ids in ${OCF_RESKEY_id}; do
        scst_sysfs_write "1" "${FABRIC_BASE}/${ids}/enabled" || {
            ocf_log err "Unable to enable target ${OCF_RESKEY_id}.";
            exit $OCF_ERR_GENERIC
        }
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Enabled iSCSI target ${OCF_RESKEY_id}"
    done

    # Be sure all Targets are finally enabled
    if [ -e "${FABRIC_BASE}/enabled" ]; then
        scst_sysfs_write "1" "${FABRIC_BASE}/enabled" || {
            ocf_log err "Unable to enable ${OCF_RESKEY_fabric} fabric.";
            exit $OCF_ERR_GENERIC
        }
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Enabled ${OCF_RESKEY_fabric} fabric."
    fi

    # Write the local configured targets into CIB -
    # need this for ALUA TPGs
    ${CRM_ATTR_TGT} --update "${OCF_RESKEY_id}"

    return $OCF_SUCCESS
}

SCSTTarget_stop() {
    local rc
    local session
    local ids

    SCSTTarget_monitor
    if [ $? =  $OCF_SUCCESS ]; then
        # Wait for the lock to manage targets
        ocf_take_lock $LOCKFILE
        ocf_release_lock_on_exit $LOCKFILE
     
        for ids in ${OCF_RESKEY_id}; do
            # The target dir is not available? Consider it stopped.
            if [ -d "${FABRIC_BASE}/${ids}" ]; then
                # Disable the target to prevent new connections
                scst_sysfs_write "0" "${FABRIC_BASE}/${ids}/enabled" || {
                    ocf_log err "Unable to disable target ${OCF_RESKEY_id}.";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Disabled ${OCF_RESKEY_fabric} target ${OCF_RESKEY_id}"

                # Forcefully close all initiator sessions
                for session in $(ls -1 "${FABRIC_BASE}/${ids}/sessions"); do
                    scst_sysfs_write "1" "${FABRIC_BASE}/${ids}/sessions/${session}/force_close"
                    ocf_log warn "Forcefully closed session from initiator ${session}.";
                done

                # Delete the target
                if [ -e "${FABRIC_BASE}/mgmt" ]; then
                    scst_sysfs_write "del_target ${ids}" ${FABRIC_BASE}/mgmt || {
                        ocf_log err "Unable to delete target ${ids}.";
                        exit $OCF_ERR_GENERIC
                    }
                    ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${OCF_RESKEY_fabric} target ${ids} deleted"
                fi
            fi
        done
    fi
    # If there is no subdirectory in the fabric base dir, no target of
    # this type is configured.
    # Disable this type of fabric after its last target was disabled,
    # and cleanup the dummy device.
    if [ $(find ${FABRIC_BASE} -mindepth 1 -maxdepth 1 -type d | wc -l) -eq 0 ]; then
        # Delete the device definition for dummy lun 0
        if [ -e "${SCST_BASE}/handlers/vdisk_nullio/LUN0_${OCF_RESKEY_fabric}" ]; then
            scst_sysfs_write "del_device LUN0_${OCF_RESKEY_fabric}" ${SCST_BASE}/handlers/vdisk_nullio/mgmt || {
                ocf_log err "Unable to delete dummy device LUN0_${OCF_RESKEY_fabric} from vdisk_nullio handler.";
                exit $OCF_ERR_GENERIC
            }
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: removed dummy device LUN0_${OCF_RESKEY_fabric} from ${OCF_RESKEY_fabric} fabric after last target was disabled."
        fi
        # Disable the fabric
        if [ -e "${FABRIC_BASE}/enabled" ]; then
            scst_sysfs_write "0" "${FABRIC_BASE}/enabled" || {
                ocf_log err "Unable to disable fabric of type ${OCF_RESKEY_fabric}.";
                exit $OCF_ERR_GENERIC
            }
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: disabled ${OCF_RESKEY_fabric} fabric after last target was disabled."
        fi
        # Delete discovery user
        if [ -e "${FABRIC_BASE}/IncomingUser" ]; then
            del_discovery_users "${OCF_RESKEY_iscsi_incoming_user_discovery}" "IncomingUser"
        fi
        if [ -e "${FABRIC_BASE}/OutgoingUser" ]; then
            del_discovery_users "${OCF_RESKEY_iscsi_outgoing_user_discovery}" "OutgoingUser"
        fi
    fi

    # Cleanup information for ALUA on target stop
    ${CRM_ATTR_TGT} --delete

    return $OCF_SUCCESS
}

SCSTTarget_monitor() {
    declare -a targets=( $(echo ${OCF_RESKEY_id}) )
    local index=${#targets[@]}
    local ids
    local path

    # check if the targets are globally disabled -
    # and if the sysfs entry is here at all.
    # in either case, consider ist stopped
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Check if fabric of type ${OCF_RESKEY_fabric} is loaded and enabled.";
    if [ -d ${FABRIC_BASE} ]; then
        if [ -e ${FABRIC_BASE}/enabled ]; then
            [ `scst_sysfs_read ${FABRIC_BASE}/enabled` -eq 1 ] || {
                ocf_log debug "Fabric of type ${OCF_RESKEY_fabric} not enabled.";
                return $OCF_NOT_RUNNING
            }
        fi
    else
        ocf_log debug "Fabric of type ${OCF_RESKEY_fabric} not loaded.";
        return $OCF_NOT_RUNNING
    fi

    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Check if target(s) ${OCF_RESKEY_id} (type ${OCF_RESKEY_fabric}) is/are loaded and enabled.";
    # if we have no sysfs entry for the individual target,
    # it's definitely stopped.
    for ids in ${OCF_RESKEY_id}; do
        [ -d ${FABRIC_BASE}/${ids} ] || {
            (( index-- ));
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Target ${OCF_RESKEY_id} is not configured.";
        }
    done
    # check if no target is here
    if [ $index -eq 0 ]; then
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: No target is configured.";
        return $OCF_NOT_RUNNING
    fi

    # if the target is there, but it is not enabled, then
    # we also consider it stopped
    for ids in ${OCF_RESKEY_id}; do
        path="${FABRIC_BASE}/${ids}/enabled"
        if [ -e ${path} ]; then
            [ `scst_sysfs_read ${path}` -eq 1 ] || {
                (( index-- ));
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Target ${OCF_RESKEY_id} is disabled.";
            }
        fi
    done
    # check if every single target is disabled
    if [ $index -eq 0 ]; then
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: All targets are disabled.";
        return $OCF_NOT_RUNNING
    fi

    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Catch the only partly configured/enabled targets" ;
    # catch only partly configured target groups
    if [[ $index -ne ${#targets[@]} ]]; then
        case $__OCF_ACTION in
            monitor|start)
                # only partly running? consider it not running,
                # so rest gets started
                return $OCF_NOT_RUNNING
                ;;
            stop)
                # so its still not all stopped, consider it running
                return $OCF_SUCCESS
                ;;
        esac
    fi

    return $OCF_SUCCESS
}

SCSTTarget_validate() {
    # Do we have all required variables?
    local required_vars
    case $OCF_RESKEY_fabric in
	iscsi|qla2x00t)
	    required_vars="id"
	;;
    esac
    for var in ${required_vars}; do
	param="OCF_RESKEY_${var}"
	if [ -z "${!param}" ]; then
	    ocf_log error "Missing resource parameter \"${var}\"!"
	    exit $OCF_ERR_CONFIGURED
	fi
    done

    # Is the configured implementation supported?
    case "$OCF_RESKEY_fabric" in
	iscsi|qla2x00t)
	    ;;
	*)
	    ocf_log error "Unsupported SCST fabric type \"${OCF_RESKEY_fabric}\"!"
	    exit $OCF_ERR_CONFIGURED
	    ;;
    esac

    # Do we have any configuration parameters that the current
    # implementation does not support?
    local unsupported_params
    local var
    local envar
    case $OCF_RESKEY_fabric in
	qla2x00t)
	    unsupported_params="iscsi_incoming_user \
                                iscsi_outgoing_user \
                                iscsi_incoming_user_discovery \
                                iscsi_outgoing_user_discovery"
	    ;;
    esac
    for var in ${unsupported_params}; do
	envar=OCF_RESKEY_${var}
	defvar=OCF_RESKEY_${var}_default
	if [ -n "${!envar}" ]; then
            if  [[ "${!envar}" != "${!defvar}" ]];then
                    case "$__OCF_ACTION" in
                        start|validate-all)
                          ocf_log warn "Configuration parameter \"${var}\"" \
                            "is not supported by by the \"${OCF_RESKEY_fabric}\" fabric" \
                            "and will be ignored." ;;
                    esac
            fi
	fi
    done

    # Do we have all required binaries?
    case $OCF_RESKEY_fabric in
        iscsi|qla2x00t)
            check_binary modprobe
            check_binary rmmod
            check_binary find
        ;;
    esac

    return $OCF_SUCCESS
}


case $1 in
  meta-data)
	meta_data
	exit $OCF_SUCCESS
	;;
  usage|help)
	SCSTTarget_usage
	exit $OCF_SUCCESS
	;;
esac

# Everything except usage and meta-data must pass the validate test
SCSTTarget_validate

case $__OCF_ACTION in
start)		SCSTTarget_start;;
stop)		SCSTTarget_stop;;
monitor|status)	SCSTTarget_monitor;;
validate-all)	;;
*)		SCSTTarget_usage
		exit $OCF_ERR_UNIMPLEMENTED
		;;
esac
rc=$?
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION : $rc"
exit $rc
