#!/bin/bash
#
# SCSTLogicalUnit
#
# Description:  Resource Agent for highly available SCSTLogicalUnits.
#               Requires installed SCST kernel module, utilities and
#               a running SCST target.
#
# Author:       Andreas Kurz
#
# License:      GNU General Public License (GPL)
#
# (c) 2015-2016 Andreas Kurz <andreas.kurz AT gmail DOT com>
#
# This resource agent is derived from the iSCSITarget resource
# agent, which itself is made available to the public under the
# following copyright:
#
# (c) 2009-2010 Florian Haas, Dejan Muhamedagic,
#               and Linux-HA contributors
#
# See usage() function below for more details ...
#
#######################################################################
# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
# Set the iSCSI fabric as default
OCF_RESKEY_fabric_default="iscsi"
: ${OCF_RESKEY_fabric=${OCF_RESKEY_fabric_default}}
# Set default t10_vend_id
OCF_RESKEY_vendor_id_default="SCST"
: ${OCF_RESKEY_vendor_id=${OCF_RESKEY_vendor_id_default}}
# Set the default SCST device handler
OCF_RESKEY_device_handler_default="vdisk_fileio"
: ${OCF_RESKEY_device_handler=${OCF_RESKEY_device_handler_default}}
# By default no initiator is allowed to access a LU
OCF_RESKEY_allowed_initiators_default=""
: ${OCF_RESKEY_allowed_initiators=${OCF_RESKEY_allowed_initiators_default}}

# Set the default path for LSI "storcli" tool to check availability
# of virtual disk exported by LSI/Avago Synchro CS controller.
OCF_RESKEY_storcli_binary_path_default="/opt/MegaRAID/storcli/storcli64"
: ${OCF_RESKEY_storcli_binary_path=${OCF_RESKEY_storcli_binary_path_default}}

# Use a default SCSI ID and SCSI SN that is unique across the cluster,
# and persistent in the event of resource migration.
# SCSI IDs are limited to 24 bytes. To have a reasonably unique
# default SCSI SN, use the first 24 bytes of an MD5 hash of
# $OCF_RESOURCE_INSTANCE
sn=`echo -n "${OCF_RESOURCE_INSTANCE}" | openssl md5 | sed -e 's/(stdin)= //'`
OCF_RESKEY_scsi_id_default="${sn:0:24}"
: ${OCF_RESKEY_scsi_id=${OCF_RESKEY_scsi_id_default}}
: ${OCF_RESKEY_vendor_specific_id=${OCF_RESKEY_scsi_id}}
# To have a reasonably unique default SCSI SN, use the first 8 bytes
# of an MD5 hash of of $OCF_RESOURCE_INSTANCE
OCF_RESKEY_scsi_sn_default=${sn:0:8}
: ${OCF_RESKEY_scsi_sn=${OCF_RESKEY_scsi_sn_default}}

# for debugging this RA
DEBUG_LOG_DIR=/tmp/SCSTLogicalUnit.ocf.ra.debug
DEBUG_LOG=$DEBUG_LOG_DIR/${OCF_RESOURCE_INSTANCE}.log
USE_DEBUG_LOG=false
ls_stat_is_dir_0700_root() {
    set -- $(command ls -ldn "$1" 2>/dev/null);
    [[ $1/$3 = drwx?-??-?/0 ]]
}
# try to avoid symlink vuln.
if ls_stat_is_dir_0700_root $DEBUG_LOG_DIR &&
    [[ -w "$DEBUG_LOG" && ! -L "$DEBUG_LOG" ]]
then
    USE_DEBUG_LOG=true
    exec 9>>"$DEBUG_LOG"
    date >&9
    echo "$*" >&9
    env | grep OCF_ | sort >&9
else
    exec 9>/dev/null
fi
# end of debugging aid

# For convenience
HOSTNAME=$(crm_node -n)
SCST_BASE="/sys/kernel/scst_tgt"
FABRIC_BASE="${SCST_BASE}/targets/${OCF_RESKEY_fabric}"
CRM_ATTR_GET_TGT="${HA_SBIN_DIR}/crm_attribute --quiet --query --name local_${OCF_RESKEY_fabric}_targets --node"
CIB_XPATH_CONNECTIVITY="${HA_SBIN_DIR}/cibadmin --query --local --xpath \
    //node_state[@uname=\"${HOSTNAME}\"]/transient_attributes//nvpair[starts-with(@name,\"#SCST${OCF_RESKEY_fabric}\")]"
STORCLI="${OCF_RESKEY_storcli_binary_path}"

# LSI/Avago Synchro CS, secondary/non-owning
# controller can also process I/O
if [ -n "${OCF_RESKEY_synchro_cs_vd_name}" ]; then
    STANDBY="nonoptimized"
else
    STANDBY="standby"
fi

# Lockfile, for LUs starting in parallel
LOCKFILE=${HA_RSCTMP}/SCSTLogicalUnit.lock
#######################################################################

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="SCSTLogicalUnit" version="0.4.4">
<version>0.4.4</version>

<longdesc lang="en">
Manages a Logical Unit for a SCST target. A Logical unit is a subdivision of
a Target, exported via a daemon that speaks a specific protocol.
</longdesc>
<shortdesc lang="en">Manages Logical Units (LUs) for SCST targets</shortdesc>

<parameters>
<parameter name="fabric" required="0" unique="1">
<longdesc lang="en">
The SCST target supports several fabric types. Must be one of "iscsi" or
"qla2x00t". If unspecified, "iscsi" is used.
</longdesc>
<shortdesc lang="en">The type of fabric</shortdesc>
<content type="string" default="${OCF_RESKEY_fabric_default}"/>
</parameter>

<parameter name="target_id" required="1" unique="1">
<longdesc lang="en">
A white-space separated list of targets this Logical Unit belongs to.
For iSCSI targets this has to be the target iSCSI Qualified Name (IQN).
Fibre Channel (qla2x00t) targets use a World Wide Name (WWN) for
identification.
</longdesc>
<shortdesc lang="en">Target identifier</shortdesc>
<content type="string" />
</parameter>

<parameter name="lun" required="1" unique="1">
<longdesc lang="en">
The Logical Unit number (LUN) exposed to initiators.
</longdesc>
<shortdesc lang="en">Logical Unit number (LUN)</shortdesc>
<content type="integer" />
</parameter>

<parameter name="path" required="1" unique="1">
<longdesc lang="en">
The path to the block device or file to be exposed.
</longdesc>
<shortdesc lang="en">Block device (or file) path</shortdesc>
<content type="string" />
</parameter>

<parameter name="device_handler" required="0" unique="1">
<longdesc lang="en">
The SCST devive handler to be used for this Logical Unit.
The supported handlers for this RA are:
vdisk_fileio, vdisk_blockio, vcdrom, vdisk_nullio
</longdesc>
<shortdesc lang="en">SCST device handler</shortdesc>
<content type="string" default="${OCF_RESKEY_device_handler_default}"/>
</parameter>

<parameter name="scsi_id" required="0" unique="1">
<longdesc lang="en">
The SCSI ID to be configured for this Logical Unit. The default
is a hash of the resource name, truncated to 24 bytes.
</longdesc>
<shortdesc lang="en">SCSI ID</shortdesc>
<content type="string" default="${OCF_RESKEY_scsi_id_default}"/>
</parameter>

<parameter name="scsi_sn" required="0" unique="1">
<longdesc lang="en">
The SCSI serial number to be configured for this Logical Unit.
The default is a hash of the resource name, truncated
to 8 bytes.
</longdesc>
<shortdesc lang="en">SCSI serial number</shortdesc>
<content type="string" default="${OCF_RESKEY_scsi_sn_default}"/>
</parameter>

<parameter name="product_id" required="0" unique="1">
<longdesc lang="en">
The SCSI product ID to be configured for this Logical Unit,
truncated to 16 bytes.
</longdesc>
<shortdesc lang="en">SCSI product ID</shortdesc>
<content type="string" />
</parameter>

<parameter name="vendor_id" required="0" unique="1">
<longdesc lang="en">
The SCSI vendor ID to be configured for this Logical Unit,
truncated to 8 bytes.
</longdesc>
<shortdesc lang="en">SCSI vendor ID</shortdesc>
<content type="string" default="${OCF_RESKEY_vendor_id_default}"/>
</parameter>

<parameter name="vendor_specific_id" required="0" unique="1">
<longdesc lang="en">
The SCSI vendor specific ID to be configured for this Logical Unit.
It defaults to the same value as the SCSI serial id, and is
truncated to 24 bytes.
</longdesc>
<shortdesc lang="en">SCSI vendor specific ID</shortdesc>
<content type="string" default="${OCF_RESKEY_scsi_id_default}"/>
</parameter>

<parameter name="additional_parameters" required="0" unique="1">
<longdesc lang="en">
Additional LU parameters. A space-separated list of "name=value" pairs
which will be passed through to the targets management
interface. Neither the name nor the value may contain whitespace.
</longdesc>
<shortdesc lang="en">List of LU parameters</shortdesc>
<content type="string" />
</parameter>

<parameter name="allowed_initiators" required="0" unique="0">
<longdesc lang="en">
Allowed initiators. A space-separated list of initiators allowed to
connect to this lun. Initiators may be listed in any syntax
the target fabric allows. If this parameter is empty or
not set, access to this lun will not be allowed from any initiator.
</longdesc>
<shortdesc lang="en">List of initiators allowed to connect
to this lun.</shortdesc>
<content type="string" default="${OCF_RESKEY_allowed_initiators_default}"/>
</parameter>

<parameter name="alua_tpg" required="0" unique="0">
<longdesc lang="en">
White-space separated list of SCST Asymmetric Logical Unit Assignment
 (ALUA) target port group names. These names must match the cluster
node names. The most left one has highest priority.

SCSI-4 ALUA is a multipathing method that allows each target port to
manage access states and path attributes using an explict method, or
implicitly using target-side configFS operations.

If at least one node-attribute is found with a name starting with
"#SCST${OCF_RESKEY_fabric_default}" (e.g. for the default "iscsi" fabric),
it is also used to calculate the ALUA state. The sum of all attribute
values has to be higher than 0 to switch to "active" state. You can use
a common connectivity-check resource like "ping" to write such a node-attribute.
</longdesc>
<shortdesc lang="en">SCST ALUA target port group name</shortdesc>
<content type="string"/>
</parameter>

<parameter name="synchro_cs_vd_name" required="0" unique="1">
<longdesc lang="en">
Name of a shared virtual drive, exported by a LSI/Avago Synchro CS
controller. This name must be the one set for the block device
used as "path".
</longdesc>
<shortdesc lang="en">Name of a LSI/Avago Synchro CS shared,
virtual drive</shortdesc>
<content type="string"/>
</parameter>

<parameter name="storcli_binary_path" required="0" unique="0">
<longdesc lang="en">
Absolute path to the "storcli" management tool. This is needed
to check the availability of shared virtual disks, exported by
LSI/Avago Synchro CS controllers.
</longdesc>
<shortdesc lang="en">Absolute path to "storcli" binary</shortdesc>
<content type="string" default="${OCF_RESKEY_storcli_binary_path_default}"/>
</parameter>

</parameters>

<actions>
<action name="start"        timeout="60" />
<action name="stop"         timeout="60" />
<action name="promote"      timeout="60" />
<action name="demote"       timeout="300" />
<action name="notify"       timeout="60" />
<action name="stop"         timeout="300" />
<action name="monitor"      depth="0" timeout="20" interval="10" />
<action name="monitor"      depth="0" timeout="20" interval="20" role="Slave" />
<action name="monitor"      depth="0" timeout="20" interval="10" role="Master" />
<action name="reload"       timeout="10" />
<action name="status"       timeout="10" interval="10" depth="0" />
<action name="meta-data"    timeout="5" />
<action name="validate-all" timeout="10" />
</actions>
</resource-agent>
END
}

#######################################################################

SCSTLogicalUnit_usage() {
	cat <<END
usage: $0 {start|stop|promote|demote|notify|status|monitor|reload|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

# Read the SCST sysfs attribute $1. See also scst/README for more information.
scst_sysfs_read() {
    local EAGAIN val

    EAGAIN="Resource temporarily unavailable"
    while true; do
        if val="$(LC_ALL=C cat "$1" 2>&1)"; then
            echo -n "${val%\[key\]}"
            return 0
	elif [ "${val/*: }" != "$EAGAIN" ]; then
            return 1
        fi
        sleep 1
    done
}

# Write $1 into the SCST sysfs attribute $2. See also scst/README for more
# information.
scst_sysfs_write() {
    local EAGAIN status

    EAGAIN="Resource temporarily unavailable"
    if status="$(LC_ALL=C; (echo -n "$1" > "$2") 2>&1)"; then
        return 0
    elif [ "${status/*: }" != "$EAGAIN" ]; then
        return 1
    fi
    scst_sysfs_read /sys/kernel/scst_tgt/last_sysfs_mgmt_res >/dev/null
}

get_index() {
    local index
    declare -a array=( $(echo -n ${2}) )

    for (( index = 0; index < ${#array[@]}; index++ )); do
        if [ "${array[$index]}" == "$1" ]; then
            echo $index
            break
        fi
    done
}

flushbufs() {
    if [ -b $OCF_RESKEY_path ]; then
        ocf_log info "${OCF_RESOURCE_INSTANCE}: Flushing outstanding I/Os to device ${OCF_RESKEY_path}..."
        # This can really take some time, allow other LUNs
        # to take the lock
        [ -e "$LOCKFILE" ] && ocf_run rm -vf $LOCKFILE
        ocf_run blockdev -v --flushbufs $OCF_RESKEY_path
    fi
}

block_dev() {
    local block="${SCST_BASE}/devices/${OCF_RESOURCE_INSTANCE}/block"

    # Block new commands for the device, drain current commands.
    if [ -e "${block}" ]; then
        ocf_log info "${OCF_RESOURCE_INSTANCE}: Waiting for device ${OCF_RESOURCE_INSTANCE} being blocked..."
        # Check if device is already blocked
        if [ "$(scst_sysfs_read ${block})" != "1 0" -a  "$(scst_sysfs_read ${block})" != "1 1" ]; then
            # This is synchronous and waits for all running commands
            # being drained.
            scst_sysfs_write "1" ${block} || {
                ocf_log err "Unable to block device ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        ocf_log info "${OCF_RESOURCE_INSTANCE}: Successfully blocked device ${OCF_RESOURCE_INSTANCE}."
    fi
}

unblock_dev() {
    local block="${SCST_BASE}/devices/${OCF_RESOURCE_INSTANCE}/block"

    # Unblock the previously blocked device.
    if [ -e "${block}" ]; then
        # Check if device is already unblocked
        if [ "$(scst_sysfs_read ${block})" != "0 0" -a  "$(scst_sysfs_read ${block})" != "0 1" ]; then
            scst_sysfs_write "0" ${block} || {
                ocf_log err "Unable to unblock device ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        ocf_log info "${OCF_RESOURCE_INSTANCE}: Successfully unblocked device ${OCF_RESOURCE_INSTANCE}."
    fi
}

update_alua_access_state() {
    local tpg="$1"
    local dev_group="${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}"

    case "${2}" in
        standby|nonoptimized)
            scst_sysfs_write "0" ${dev_group}/target_groups/${tpg}/preferred || {
                ocf_log err "ALUA - Unable to set preferred to 0 - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
            ;;
        active)
            scst_sysfs_write "1" ${dev_group}/target_groups/${tpg}/preferred || {
                ocf_log err "ALUA - Unable to set preferred to 1 - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
            ;;
    esac

    # If desired state is already set, don't block/unblock the device
    if [ "$(scst_sysfs_read ${dev_group}/target_groups/${tpg}/state)" != ${2} ]; then
        block_dev
	# see scst/README: Change the ALUA state to "transitioning". At this moment all open
	# file handles will be closed.
        scst_sysfs_write "transitioning" ${dev_group}/target_groups/${tpg}/state || {
            ocf_log err "ALUA - Unable to set state to transitioning - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
	# Be sure all in-flight data is flushed ...
        flushbufs
	# ... before switching to desired state
        scst_sysfs_write "${2}" ${dev_group}/target_groups/${tpg}/state || {
            ocf_log err "ALUA - Unable to set state to ${2} - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
        unblock_dev
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - TPG ${tpg} is in ${2} state."

    return $OCF_SUCCESS
}

update_master_score() {
    local score
    local index
    local vdname
    local connectivity
    declare -a tpgs=( $(echo -n ${OCF_RESKEY_alua_tpg}) )
    score=0
    index=$(get_index ${HOSTNAME} "${OCF_RESKEY_alua_tpg}")
    connectivity=$(${CIB_XPATH_CONNECTIVITY} 2>/dev/null | sed -ne 's/^[[:space:]]*<.* value="\([^"]*\)".*>$/\1/p' | \
        awk '{sum += $1} END {print sum}')

    # We have an array with all TPGs, the left most
    # one receives the highest score. TPGs must be named
    # like the node names in Pacemaker.
    score=$(( ( ${#tpgs[@]} - $index ) * 1000 ));

    # Check availability of shared, virtual LSI/Avago Synchro
    # CS drive.
    if [ -n "${OCF_RESKEY_synchro_cs_vd_name}" ]; then
        vdname=$( ${STORCLI} /call/vall show | \
            awk -v pattern="[[:space:]]+${OCF_RESKEY_synchro_cs_vd_name}[[:space:]]*$" \
            '$0 ~ pattern {print $NF}' )
        # The virtual drive is not available,
        # demote the LUN but don't set score to
        # zero.
        if [ -z "${vdname}" ]; then
            score=10
            ocf_log debug "Virtual, shared drive ${OCF_RESKEY_synchro_cs_vd_name} not active/optimized on this node."
        fi
    fi

    # If there is a connectivity-check writing one (or more)
    # attribute(s) like "#SCSTiscsi-netX" this is also evaluated.
    # The value must be higher than 0 after summing up the
    # values from all transient attributes found.
    if [ -n "${connectivity}" ] && [ $connectivity -le 0 ]; then
        # Don't set the score to 0 if for any reason all nodes
        # loose their connectivity at once - still allow to promote
        # a master.
        score=$(( ${#tpgs[@]} - $index ))
        ocf_log debug "Setting master score to 0 because of missing connectivity."
    fi

    ocf_log debug "Setting master score to $score"
    if [ $score -gt 0 ]; then
	set_master_score $score
    else
	remove_master_score
    fi
}

set_master_score() {
    # Use quiet mode (-Q) to quench logging. Actual score updates
    # will get logged by attrd anyway
    ocf_run ${HA_SBIN_DIR}/crm_master -Q -l reboot -v $1
}

remove_master_score() {
    ocf_run ${HA_SBIN_DIR}/crm_master -l reboot -D
}

SCSTLogicalUnit_acls() {
    declare -a exports_del
    local export_full_path
    local exports
    local index
    local initiator
    local ini_path
    local session
    local target

    # Don't manipulate anything during a probe
    ocf_is_probe && return $OCF_SUCCESS

    # Wait for the lock to manage lun exports and
    # ini_groups.
    ocf_take_lock $LOCKFILE
    ocf_release_lock_on_exit $LOCKFILE

    for target in ${OCF_RESKEY_target_id}; do
        ini_path="${FABRIC_BASE}/${target}/ini_groups"
        # Get all existing acls for this LUN, fill it in an array.
        exports_del=( $(ls -1d ${ini_path}/*/luns/${OCF_RESKEY_lun} 2>/dev/null | grep -Ev '/mgmt$' | tr '\n' ' ') )

        # Only need to add acls on start,monitor or reload
        case $__OCF_ACTION in
            monitor|start|reload)
                ocf_log debug "Updating allowed initiators for LUN ${OCF_RESKEY_lun}, target ${target}."
                # Create one initiator group per initiator.
                for initiator in ${OCF_RESKEY_allowed_initiators}; do
                    # Create the ini_group
                    if [ ! -d "${ini_path}/${initiator}" ]; then
                        scst_sysfs_write "create ${initiator}" ${ini_path}/mgmt || {
                            ocf_log err "Unable to create initiator group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Created initiator group ${initiator} for target ${target}."
                    fi

                    # allow only one initiator
                    if [ ! -e "${ini_path}/${initiator}/initiators/${initiator}" ]; then
                        scst_sysfs_write "add ${initiator}" ${ini_path}/${initiator}/initiators/mgmt || {
                            ocf_log err "Unable to add initiator ${initiator} to group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Allowed initiator ${initiator} to group ${initiator} for target ${target}."
                    fi
                    # delete all other initiators
                    for index in $(ls -1 ${ini_path}/${initiator}/initiators 2>/dev/null | grep -Ev "^(mgmt|${initiator})$" | tr '\n' ' '); do
                        scst_sysfs_write "del ${index}" ${ini_path}/${initiator}/initiators/mgmt || {
                            ocf_log err "Unable to delete initiator ${index} from group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Removed initiator ${index} from group ${initiator} for target ${target}."
                    done

                    # Always add LUN 0 to the initiator group
                    if [ ! -d "${ini_path}/${initiator}/luns/0" ]; then
                        scst_sysfs_write "add LUN0_${OCF_RESKEY_fabric} 0" ${ini_path}/${initiator}/luns/mgmt || {
                            ocf_log err "Unable to export LUN0_${OCF_RESKEY_fabric} with LUN 0 via initiator group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Exported LUN0_${OCF_RESKEY_fabric} lun 0 via initiator group ${initiator} for target ${target}."
                    fi

                    # Finally export the LU for this initiator
                    if [ ! -d "${ini_path}/${initiator}/luns/${OCF_RESKEY_lun}" ]; then
                        scst_sysfs_write "add ${OCF_RESOURCE_INSTANCE} ${OCF_RESKEY_lun}" ${ini_path}/${initiator}/luns/mgmt || {
                            ocf_log err "Unable to export ${OCF_RESOURCE_INSTANCE} whith LUN ${OCF_RESKEY_lun} via initiator group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Exported ${OCF_RESOURCE_INSTANCE} with LUN ${OCF_RESKEY_lun} via initiator group ${initiator} for target ${target}."
                    fi

                    # Remove valid export from "clean-them-up"-array.
                    export_full_path="${ini_path}/${initiator}/luns/${OCF_RESKEY_lun}"
                    for index in "${!exports_del[@]}"; do
                        if [ "${exports_del[$index]}" = "$export_full_path" ]; then
                        unset exports_del[$index]
                            break
                        fi
                    done
                done
                # Remove exports for the current LU, that are not allowed.
                ocf_log debug "Cleanup acls for LUN ${OCF_RESKEY_lun}, target ${target} ini_group ${OCF_RESOURCE_INSTANCE}."
                for exports in "${exports_del[@]}"; do
                    if [ -d "${exports}" ]; then
                        # remove the lun from the ini_group
                        scst_sysfs_write "del ${OCF_RESKEY_lun}" ${exports}/../mgmt || {
                            ocf_log err "Unable to unexport LUN ${OCF_RESKEY_lun} - ${exports}";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "Unexported LUN ${OCF_RESKEY_lun} - ${exports}"
                    fi
                done
            ;;
            stop)
                # Clear the acls on stop of the lun.
                ocf_log debug "Remove all exports for LUN ${OCF_RESKEY_lun}, target ${target}."
                for exports in "${exports_del[@]}"; do
                    if [ -d "${exports}" ]; then
                        scst_sysfs_write "del ${OCF_RESKEY_lun}" ${exports}/../mgmt || {
                            ocf_log err "Unable to unexport LUN ${OCF_RESKEY_lun} - ${exports}";
                            exit $OCF_ERR_GENERIC
                        }
                    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Unexported LUN ${OCF_RESKEY_lun} - ${exports}"
                    fi
                done
            ;;
        esac
        # remove empty (or only exporting lun 0) ini_groups
        for initiator in $(find ${FABRIC_BASE}/${target}/ini_groups/ -mindepth 1 -maxdepth 1 -type d) ; do
            if [ $(find ${initiator}/luns -mindepth 1 -maxdepth 1 -type d ! -name '0' | wc -l) -eq 0 ] ; then
                # Forcefully close all sessions.
                # When using iSCSI MPIO, several sessions per initiator can be available.
                for session in $(ls -1d ${FABRIC_BASE}/${target}/sessions/${initiator##*/} \
                                        ${FABRIC_BASE}/${target}/sessions/${initiator##*/}_* 2>/dev/null) ; do
                    scst_sysfs_write "1" "${session}/force_close" && \
                    ocf_log warn "Forcefully closed session from initiator ${initiator##*/}."
                done
                # Delete the ini_group
                scst_sysfs_write "del ${initiator##*/}" ${FABRIC_BASE}/${target}/ini_groups/mgmt || {
                     ocf_log err "Unable to delete initiator group ${initiator##*/} from target ${target}.";
                     exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Deleted empty initiator group ${initiator##*/} from target ${target}."
           fi
        done
    done

    return $OCF_SUCCESS
}

SCSTLogicalUnit_start() {
    SCSTLogicalUnit_monitor
    rc=$?
    case $rc in
        $OCF_SUCCESS|$OCF_RUNNING_MASTER) return $rc ;;
    esac

    local all_params
    local dev_path
    local dev_group
    local group_id
    local index
    local initiator
    local ini_path
    local handler_path
    local param
    local rel_tgt_id
    local target
    local tpg
    local tpg_base

    case $OCF_RESKEY_fabric in
        iscsi)    tpg_base=10001 ;;
        qla2x00t) tpg_base=20001 ;;
    esac
    handler_path="${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}"
    dev_path="${handler_path}/${OCF_RESOURCE_INSTANCE}"

    # Set all additional parameters
    all_params=""
    for param in ${OCF_RESKEY_additional_parameters}; do
        all_params="${all_params}; ${param}"
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Prepared specific parameter \"${all_params}\" for device handler ${OCF_RESKEY_device_handler}."

    # Check if handler is loaded
    if [ ! -e "${handler_path}" ]; then
        ocf_log err "Device handler ${OCF_RESKEY_device_handler} not loaded.";
        exit $OCF_ERR_GENERIC
    fi

    # Configure the backend device for the LU, name the
    # device like the cluster resource.
    if [ ! -e "${dev_path}" ]; then
        scst_sysfs_write "add_device ${OCF_RESOURCE_INSTANCE} filename=${OCF_RESKEY_path}${all_params}" ${handler_path}/mgmt || {
            ocf_log err "Unable to add device ${OCF_RESOURCE_INSTANCE} with path ${OCF_RESKEY_path} to ${OCF_RESKEY_device_handler} handler.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Add device ${OCF_RESOURCE_INSTANCE} whith path ${OCF_RESKEY_path}."

    # Set the SCSI device id aka T10 device id
    if [ -n "${OCF_RESKEY_scsi_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_scsi_id:0:24}" ${dev_path}/t10_dev_id || {
            ocf_log err "Unable to set T10 device id ${OCF_RESKEY_scsi_id:0:24} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set SCSI device id to ${OCF_RESKEY_scsi_id:0:24}."

    # Set the SCSI vendor specific id
    if [ -n "${OCF_RESKEY_vendor_specific_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_vendor_specific_id:0:24}" ${dev_path}/vend_specific_id || {
            ocf_log err "Unable to set vendor specific id ${OCF_RESKEY_vendor_specific_id:0:24} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set SCSI vendor specific id to ${OCF_RESKEY_vendor_specific_id:0:24}."

    # Set the SCSI device serial number aka unit serial number
    if [ -n "${OCF_RESKEY_scsi_sn}" ]; then
        scst_sysfs_write "${OCF_RESKEY_scsi_sn:0:8}" ${dev_path}/usn || {
            ocf_log err "Unable to set usn ${OCF_RESKEY_scsi_sn:0:8} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set SCSI serial number to ${OCF_RESKEY_scsi_sn}."

    # Set the SCSI product id
    if [ -n "${OCF_RESKEY_product_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_product_id:0:15}" ${dev_path}/prod_id || {
            ocf_log err "Unable to set product id ${OCF_RESKEY_product_id:0:15} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set product id to ${OCF_RESKEY_product_id:0:15}."

    # Set the SCSI vendor id
    if [ -n "${OCF_RESKEY_vendor_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_vendor_id:0:8}" ${dev_path}/t10_vend_id || {
            ocf_log err "Unable to set t10_vend_id ${OCF_RESKEY_vendor_id:0:8} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set vendor id to ${OCF_RESKEY_vendor_id:0:8}."

    # Prepare for ALUA if configured
    if [ -n "${OCF_RESKEY_alua_tpg}" ]; then
        # Sort the tpgs so we can later
        # apply "rel_tgt_id"s in a consistent way.
        declare -a tpgs=( $(for tpg in ${OCF_RESKEY_alua_tpg}; do echo ${tpg};done | sort -bdf) )

        # For ALUA, create create a device group for this lun
        # and assign a device to the group
        dev_group="${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}"
        if [ ! -d "${dev_group}" ]; then
            scst_sysfs_write "create ${OCF_RESOURCE_INSTANCE}" ${SCST_BASE}/device_groups/mgmt || {
                ocf_log err "Unable to create device_group for device ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Created device_group ${OCF_RESOURCE_INSTANCE}."

        # Add the device to its device_group
        if [ ! -e "${dev_group}/devices/${OCF_RESOURCE_INSTANCE}" ]; then
            scst_sysfs_write "add ${OCF_RESOURCE_INSTANCE}" ${dev_group}/devices/mgmt || {
                ocf_log err "Unable to add device ${OCF_RESOURCE_INSTANCE} to device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Added device ${OCF_RESOURCE_INSTANCE} to device_group ${OCF_RESOURCE_INSTANCE}."

        # The TPGs have to be named exactly as the node names (as Pacemaker uses it)
        # for "multi-node targets". The position decides about the TPG id.
        for tpg in "${tpgs[@]}"; do
            # Automatically generate group_id for each TPG
            # lun_id + ( "position of tpg in list" * 1000 )
            group_id=$(( ${OCF_RESKEY_lun} + ($(get_index ${tpg} "${tpgs[*]}") * 1000) ))

            # Create the TPGs, one for each node
            if [ ! -d "${dev_group}/target_groups/${tpg}" ]; then
                scst_sysfs_write "create ${tpg}" ${dev_group}/target_groups/mgmt || {
                    ocf_log err "Unable to create target_group ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}.";
                    exit $OCF_ERR_GENERIC
                }
            fi
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Created target_group ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}."

            # Set the id for ALUA TPG
            if [ -d "${dev_group}/target_groups/${tpg}" ]; then
                scst_sysfs_write "${group_id}" ${dev_group}/target_groups/${tpg}/group_id || {
                    ocf_log err "Unable to set id ${group_id} for TPG ${tpg} and device_group ${OCF_RESOURCE_INSTANCE}.";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set id ${group_id} for TPG ${tpg} and device_group ${OCF_RESOURCE_INSTANCE}."

                # By default the TPG is not preferred and in standby or unoptimized mode
                scst_sysfs_write "0" ${dev_group}/target_groups/${tpg}/preferred || {
                    ocf_log err "Unable to set \"preferred\" to 0 - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                }
                scst_sysfs_write "${STANDBY}" ${dev_group}/target_groups/${tpg}/state || {
                    ocf_log err "Unable to set state to \"${STANDBY}\" - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: TPG ${tpg} for device_group ${OCF_RESOURCE_INSTANCE} is ${STANDBY}."

                # Sort the targets in local_targets (like the TPGs) so we can
                # apply "rel_tgt_id"s in a consistent way.
                declare -a local_targets=( $(for target in $(${CRM_ATTR_GET_TGT} ${tpg} 2>/dev/null); do echo ${target};done | sort -bdf) )
                for target in "${local_targets[@]}"; do
                    # We need a unique rel_tgt_id for every port in the TPG,
                    # also for multiple ports per node.
                    rel_tgt_id=$(( ($(get_index ${tpg} "${tpgs[*]}") * 1000 ) + \
                                   ($(get_index ${target} "${local_targets[*]}") + ${tpg_base} ) ))
                    if [ -d "${dev_group}/target_groups/${tpg}" ]; then
                        if [ ! -e "${dev_group}/target_groups/${tpg}/${target}" ]; then
                            scst_sysfs_write "add ${target}" ${dev_group}/target_groups/${tpg}/mgmt || {
                                ocf_log err "Unable to add target ${target} to TPG ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}.";
                                exit $OCF_ERR_GENERIC
                            }
                            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Added target ${target} to TPG ${tpg} - device_group ${OCF_RESOURCE_INSTANCE}."
                        fi

                        if [ -d "${dev_group}/target_groups/${tpg}/${target}" ]; then
                            scst_sysfs_write "${rel_tgt_id}" ${dev_group}/target_groups/${tpg}/${target}/rel_tgt_id || {
                                ocf_log err "Unable to set relative target id ${rel_tgt_id} for target ${target} - device_group ${OCF_RESOURCE_INSTANCE}.";
                                exit $OCF_ERR_GENERIC
                            }
                            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set rel_tgt_id ${rel_tgt_id} for target ${target} - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}."
                        fi
                   fi
                done
            fi
        done
    fi

    # Make sure the device is unblocked.
    unblock_dev
    # export the LU to all allowed initiators
    SCSTLogicalUnit_acls

    ocf_is_ms && update_master_score

    return $OCF_SUCCESS
}

SCSTLogicalUnit_reload() {
    case $OCF_RESKEY_fabric in
	iscsi|qla2x00t)
            SCSTLogicalUnit_start
	    ;;
    esac

    return $OCF_SUCCESS
}

SCSTLogicalUnit_stop() {
    local ini_path
    local target
    local initiator

    SCSTLogicalUnit_monitor
    # For a more gracefull stop, block the device before
    # starting to deconfigure it.
    block_dev
    SCSTLogicalUnit_acls

    # Delete the device_group definition for LU
    if [ -d "${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}" ]; then
        scst_sysfs_write "del ${OCF_RESOURCE_INSTANCE}" ${SCST_BASE}/device_groups/mgmt || {
            ocf_log err "Unable to delete device_group ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Deleted device_group ${OCF_RESOURCE_INSTANCE}."

    # Delete the device definition for LU
    if [ -e "${SCST_BASE}/devices/${OCF_RESOURCE_INSTANCE}" ]; then
        scst_sysfs_write "del_device ${OCF_RESOURCE_INSTANCE}" ${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}/mgmt || {
            ocf_log err "Unable to delete device ${OCF_RESOURCE_INSTANCE} from ${OCF_RESKEY_device_handler} handler.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Deleted device ${OCF_RESOURCE_INSTANCE} from ${OCF_RESKEY_device_handler} handler."

    # In case of a block device, flush any outstanding I/O to the device
    flushbufs

    remove_master_score

    return $OCF_SUCCESS
}

SCSTLogicalUnit_monitor() {
    local alua_state
    local lun_path
    local handler_path
    local dev_path
    local target
    local initiator
    local index
    local counter
    declare -a ids=( $(echo -n ${OCF_RESKEY_target_id}) )

    handler_path="${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}"
    dev_path="${handler_path}/${OCF_RESOURCE_INSTANCE}"
    alua_state="${STANDBY}"
    index=${#ids[@]}

    # If our backing device (or file) doesn't even exist, we're not running
    [ -e ${OCF_RESKEY_path} ] || {
        ocf_log warn "Backing device (or file) ${OCF_RESKEY_path} not available - Assuming LU ${OCF_RESOURCE_INSTANCE} is not up.";
        return $OCF_NOT_RUNNING
    }

    # If our device handler is not available we're not running
    [ -e ${handler_path} ] || {
        ocf_log warn "Device handler ${OCF_RESKEY_device_handler} not loaded - Assuming LU ${OCF_RESOURCE_INSTANCE} is not up.";
        return $OCF_NOT_RUNNING
    }

    # If our device is not configured we're not running
    [ -e ${dev_path} ] || {
        ocf_log debug "Device ${OCF_RESOURCE_INSTANCE} of type ${OCF_RESKEY_device_handler} not available - Assuming LU ${OCF_RESOURCE_INSTANCE} is not up.";
        return $OCF_NOT_RUNNING
    }

    # Check all targets
    for target in ${OCF_RESKEY_target_id}; do
        # Fill an array with all exports of this LU
        declare -a lun_path=( $(ls -1d ${FABRIC_BASE}/${target}/ini_groups/*/luns/${OCF_RESKEY_lun}/device 2>/dev/null | tr '\n' ' ') )
        counter=0
        # Check if they all export the same backend device
        for initiator in "${lun_path[@]}"; do
            [ -e "$initiator" ]  && [ `scst_sysfs_read "${initiator}/filename"` = "${OCF_RESKEY_path}" ] && (( counter++ ))
        done
        [ $counter -eq ${#lun_path[@]} ] && (( index-- ))
    done

    if [[ $index -eq 0 ]]; then
        # The lun seems to be availaddble, also verify/fix its acls,
        # but not on stop
        [ "$__OCF_ACTION" = "stop" ] || SCSTLogicalUnit_acls

        # Now check the ALUA state
        if [ -n "${OCF_RESKEY_alua_tpg}" ] ; then
            if [ -e "${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}/target_groups/${HOSTNAME}/state" ]; then
                alua_state="$(scst_sysfs_read ${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}/target_groups/${HOSTNAME}/state)"
            fi
            case $alua_state in
                active)
                    update_master_score
                    return $OCF_RUNNING_MASTER
                    ;;
                standby|nonoptimized)
                    update_master_score
                    return $OCF_SUCCESS
                    ;;
                *)
                    return $OCF_FAILED_MASTER
                    ;;
           esac
        fi
        return $OCF_SUCCESS
    fi
    # catch only "half"-configured LUNs, manual intervention
    # may be needed ... but only on start or monitor
    if [[ $index -ne ${#ids[@]} ]]; then
        case $__OCF_ACTION in
            monitor|start)
                ocf_log error "${OCF_RESOURCE_INSTANCE}/LUN ${OCF_RESKEY_lun} with path/file ${OCF_RESKEY_path} is not associated correctly to all its targets!"
                remove_master_score
                exit $OCF_ERR_GENERIC
                ;;
            stop)
                remove_master_score
                return $OCF_SUCCESS
                ;;
        esac
    fi

    return $OCF_NOT_RUNNING
}

SCSTLogicalUnit_promote() {
    SCSTLogicalUnit_monitor
    rc=$?

    case $rc in
        $OCF_SUCCESS)
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - currently in Slave state, TPG $HOSTNAME is ${STANDBY}/not-preferred"
            ;;
        $OCF_NOT_RUNNING)
            ocf_log info "ALUA: Trying to promote resource ${OCF_RESOURCE_INSTANCE} that is not running, start it ..."
            # Resource is down? ... start it
            SCSTLogicalUnit_start
            ;;
        $OCF_RUNNING_MASTER)
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - already in Master state, TPG $HOSTNAME is active/preferred"
            return $OCF_SUCCESS
            ;;
        *)
            ocf_log error "Unexpected error, unable to promote TPG $HOSTNAME for LU ${OCF_RESOURCE_INSTANCE}."
            exit $rc
    esac

    # Now do the promotion
    update_alua_access_state $HOSTNAME active || {
        ocf_log error "Unable to set ALUA access state for lun_${OCF_RESKEY_lun}/${OCF_RESOURCE_INSTANCE} to active/preferred!";
        exit $OCF_ERR_GENERIC
    }
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - promoting was successfull, TPG $HOSTNAME is now active/preferred"

    return $OCF_SUCCESS
}

SCSTLogicalUnit_demote() {
    SCSTLogicalUnit_monitor
    rc=$?

    case $rc in
        $OCF_RUNNING_MASTER)
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - currently in Master state, TPG $HOSTNAME is active/preferred"
            ;;
        $OCF_NOT_RUNNING)
            ocf_log error "ALUA: Trying to demote resource ${OCF_RESOURCE_INSTANCE} that is not running!"
            # Resource is down? ... not expected to receive
            # a demote in this state, error out.
            exit $OCF_ERR_GENERIC
            ;;
        $OCF_SUCCESS)
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - already in Slave state, TPG $HOSTNAME is in ${STANDBY} mode"
            return $OCF_SUCCESS
            ;;
        *)
            ocf_log error "Unexpected error, unable to demote TPG $HOSTNAME for LU ${OCF_RESOURCE_INSTANCE}."
            exit $rc
    esac

    # Now do the demotion
    update_alua_access_state $HOSTNAME ${STANDBY} || {
        ocf_log error "Unable to set ALUA access state for lun_${OCF_RESKEY_lun}/${OCF_RESOURCE_INSTANCE} to ${STANDBY}!";
        exit $OCF_ERR_GENERIC
    }
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - demote was successfull, TPG $HOSTNAME is now ${STANDBY}"

    # In case of a block device, flush any outstanding I/O to the device
    flushbufs

    return $OCF_SUCCESS
}

SCSTLogicalUnit_notify() {
    local n_type=$OCF_RESKEY_CRM_meta_notify_type
    local n_op=$OCF_RESKEY_CRM_meta_notify_operation
    local demoteit=$OCF_RESKEY_CRM_meta_notify_demote_uname
    local promoteit=$OCF_RESKEY_CRM_meta_notify_promote_uname
    local stopit=$OCF_RESKEY_CRM_meta_notify_stop_uname
    local startit=$OCF_RESKEY_CRM_meta_notify_start_uname
    local master=$OCF_RESKEY_CRM_meta_notify_master_uname
    local slave=$OCF_RESKEY_CRM_meta_notify_slave_uname
    local node
    local instance

    case $n_type/$n_op in
        post/start)
            # Switch all new slave instances TPG to standby
            for node in $startit; do
                # Do we have any master(s) at all and did the start happened locally?
                if [ "$node" = "$HOSTNAME" ]; then
                    # We are slave: be sure the master(s) TPG is also
                    # set to active (without luns) on this node.
                    # We rely on default standby state on creation.
                    for instance in $master; do
                         update_alua_access_state $instance active
                    done
                else
                    # Be sure to set correct slave mode
                    update_alua_access_state $node ${STANDBY}
                fi
            done
            ;;
        post/promote)
            for node in $promoteit; do
                # Switch all new master instances TPG to active.
                update_alua_access_state $node active
            done
            ;;
        post/demote)
            for node in $demoteit; do
                # Switch all new slave instances TPG to standby
                update_alua_access_state $node ${STANDBY}
            done
            ;;
        post/stop)
            # So some node(s) has/have inactive resources, is it me?
            for node in $stopit; do
                if [ "$node" != "$HOSTNAME" ]; then
                    # Another node stopped the resource,
                    # its TPGs are definitely offline
                    update_alua_access_state $node offline
                fi
            done
            ;;
    esac

    return $OCF_SUCCESS
}

SCSTLogicalUnit_validate() {
    # Do we have all required variables?
    for var in target_id lun path; do
	param="OCF_RESKEY_${var}"
	if [ -z "${!param}" ]; then
	    ocf_log error "Missing resource parameter \"$var\"!"
	    exit $OCF_ERR_CONFIGURED
	fi
    done

    # Do we have a valid LUN?
    # We always use dummy LUN 0
    [ $OCF_RESKEY_lun -ge 1 ]
    case $? in
        0)
            # OK
            ;;
        1)
            ocf_log err "Invalid LUN $OCF_RESKEY_lun (must be greater than 0)."
            exit $OCF_ERR_CONFIGURED
            ;;
        *)
            ocf_log err "Invalid LUN $OCF_RESKEY_lun (must be an integer)."
            exit $OCF_ERR_CONFIGURED
            ;;
    esac

    # Is the configured fabric supported?
    case "$OCF_RESKEY_fabric" in
	iscsi|qla2x00t)
            :
	    ;;
	*)
	    ocf_log error "Unsupported SCST target fabric \"$OCF_RESKEY_fabric\"!"
	    exit $OCF_ERR_CONFIGURED
	    ;;
    esac

    # Do we have any configuration parameters that the current
    # fabric does not support?
    local unsupported_params
    local var
    local envar
    case $OCF_RESKEY_fabric in
	iscsi|qla2x00t)
	    unsupported_params=""
	    ;;
    esac
    for var in ${unsupported_params}; do
	envar=OCF_RESKEY_${var}
	defvar=OCF_RESKEY_${var}_default
	if [ -n "${!envar}" ]; then
	    if  [[ "${!envar}" != "${!defvar}" ]];then
	        case "$__OCF_ACTION" in
                    start|validate-all)
                      ocf_log warn "Configuration parameter \"${var}\"" \
                       "is not supported by SCST's ${OCF_RESKEY_fabric} fabric" \
                       "and will be ignored." ;;
	        esac
	    fi
	fi
    done

    # Do we have all required binaries?
    case $OCF_RESKEY_fabric in
        iscsi)
            check_binary find
            ;;
    esac
    # When exporting a shared virtual disk via
    # LSI/Avago Synchro CS we need the storcli tool
    # to check its availability.
    if [[ -n "${OCF_RESKEY_synchro_cs_vd_name}" ]]; then
        check_binary "${STORCLI}"
        check_binary awk
    fi

    if ! ocf_is_probe; then
        # Is the required kernel functionality available?
	case $OCF_RESKEY_fabric in
	    iscsi|qla2x00t)
		[ -d "${FABRIC_BASE}" ] || {
		    ocf_log err "${FABRIC_BASE} does not exist or is not a directory -- check if required modules are loaded.";
		    exit $OCF_ERR_INSTALLED
                }
		;;
	esac

	[ -d "${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}" ] || {
	    ocf_log err "${OCF_RESKEY_device_handler} handler does not exist or is not a directory -- check if required modules are loaded.";
	    exit $OCF_ERR_INSTALLED
        }
    fi

    return $OCF_SUCCESS
}


case $1 in
  meta-data)
	meta_data
	exit $OCF_SUCCESS
	;;
  usage|help)
	SCSTLogicalUnit_usage
	exit $OCF_SUCCESS
	;;
esac

if $USE_DEBUG_LOG ; then
    exec 2>&9
    set -x
fi

# Everything except usage and meta-data must pass the validate test
SCSTLogicalUnit_validate

case $__OCF_ACTION in
    start)
        SCSTLogicalUnit_start
        ;;
    stop)
        SCSTLogicalUnit_stop
        ;;
    monitor|status)
        SCSTLogicalUnit_monitor
        ;;
    reload)
        ocf_log info "Reloading..."
        SCSTLogicalUnit_reload
        ;;
    promote)
        SCSTLogicalUnit_promote
        ;;
    demote)
        SCSTLogicalUnit_demote
        ;;
    notify)
        SCSTLogicalUnit_notify
        ;;
    validate-all)
        ;;
    *)
        SCSTLogicalUnit_usage
        exit $OCF_ERR_UNIMPLEMENTED
	;;
esac
rc=$?
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION : $rc"
exit $rc
